package Practice;

import java.util.Scanner;

public class LinkedList {
	
	//@@(1)@@ connect node and create LinkedList
	public static Node<Integer> createLL(){
		Node<Integer> n1 = new Node<Integer>(10);
		Node<Integer> n2 = new Node<Integer>(20);
		Node<Integer> n3 = new Node<Integer>(30);
		Node<Integer> n4 = new Node<Integer>(40);
		n1.next = n2;
		n2.next = n3;
		n3.next = n4;
		return n1;
	}

	
	//@@(2)@@ print the LinkedList
	public static void printLL(Node<Integer> head) {
		Node<Integer> temp = head;
		while(temp != null) {
			System.out.print(temp.data+ " ");
			temp = temp.next;
		}
	}
	
	//@@(3)@@ take input from user till -1 and make Linkedlist
	// time complexicity => O(n2)
	public static Node<Integer> takeInputLL(){
		Scanner scn = new Scanner(System.in);
		System.out.println("take input in way:: n1 n2 n3 .... -1");
		int data = scn.nextInt();
		Node<Integer> head = null;
		while(data != -1) {
		Node<Integer> currNode = new Node<Integer>(data);
		if(head == null) {
			//make this node as head node
			head = currNode;
		}else {
			Node<Integer> tail = head;
			while(tail.next != null) {
				tail = tail.next;
			}
			//now tail refers last Node
			//connect current node after last Node
			tail.next = currNode;
		}
		data = scn.nextInt();
		}
		return head;
	}

	//@@(4)@@ take input from user till -1 and make Linkedlist
		// time complexicity => O(n)
	public static Node<Integer> takeInputLLBetter(){
		System.out.println("take input in a way :n1 n2 n3 ...");
		Scanner scn = new Scanner(System.in);
		int data = scn.nextInt();
		Node<Integer> head = null;
		Node<Integer> tail = null;
		
		while(data != -1) {
			Node<Integer> currNode = new Node<Integer>(data);
			if(head == null) {
				head = currNode;
				tail = currNode;
				
			}else {
				tail.next = currNode;
				tail = currNode;
			}
			
			data = scn.nextInt();
		}
		return head;
	}
	
	//@@(4)@@ find the length of LinkedList (Count of Node)
	public static int LinkedListLength(Node<Integer> head) {
		Node<Integer> temp = head;
		int count = 0;
		while(temp != null) {
			count++;
			temp = temp.next; 
		}
		return count;
	}
	
	//@@(5)@@ increase the Node data by 1 of LinkedList
	public static void incrementData(Node<Integer> head) {
		Node<Integer> temp = head;
		while(temp != null) {
			temp.data++;
			temp = temp.next;
		}
	}
	
	//@@(6)@@ find a node in linked list and evaluate its
	       // position if not present then return -1 (position start from 0)
	public static int nodePosition(Node<Integer> head , int elem) {
		Node<Integer> temp = head;
		int pos = 0;
		while(temp != null) {
			if(temp.data == elem) {
				return pos;
			}
			temp = temp.next;
			pos++;
		}
		return -1;
	}
	
	//@@(7)@@ you have been given singly LinkedList which is sorted in ascending
	   //- order you have to remove continuous duplicates from LL and it contains
	   // only unique elements
	public static Node<Integer> uniqueElemLL(Node<Integer> head){
		if(head == null || head.next == null) {
			return head;
		}
		Node<Integer> temp = head;
		while(temp.next != null) {
			if(temp.data == temp.next.data) {
				temp.next = temp.next.next;
			}else {
				temp = temp.next;
			}
		}
		return head;
	}
	
	//@@(8)@@ find the node of ith position(position starts from 0)
	public static void ithPosElemInLL(Node<Integer> head , int i) {
		Node<Integer> temp = head;
		int currpos = 0;
		while(temp != null && currpos < i) {
			temp = temp.next; 
			currpos++;
		}
		if(temp != null) {
			System.out.println(temp.data);
		}
	}
	
	//@@(9)@@ find the kth node from end in LinkedList
	public static int kthFromLast(Node<Integer> head , int k) {
		Node<Integer> slow = head;
		Node<Integer> fast = head;
		int lenghtLL = LinkedListLength(head);
		if(lenghtLL < k) {
			System.out.println("Invalid input of k");
			return -1;
		}
		for(int i=0; i < k ; i++) {
			fast = fast.next;
		}
		while(fast.next != null) {
			slow = slow.next;
			fast = fast.next;
		}
		return slow.data;
	}
	
  //@@(10)@@ delete node of linked list at position(first , middle/end)
	public static Node<Integer> deleteNodeInLL(Node<Integer> head , int pos){
		if(head == null) {
			return head;
		}
		if(pos == 0) {
			return head.next;
		}else {
			int currpos = 0;
			Node<Integer> temp = head;
			while(temp != null && currpos < pos-1) {
				temp = temp.next;
				currpos++;
			}
			if(temp != null || temp.next != null) {
				temp.next = temp.next.next;
			}
		}
		return head;
	}
	
	//@@(11)@@ insert node in LinkedList at position(first , last/mid)
	public static Node<Integer> insertNodeInLL(Node<Integer> head, int pos , int elem){
		
		Node<Integer> currNode = new Node<Integer>(elem);
		if(pos == 0) {
			currNode.next = head;
			head = currNode;
			return head;
		}else {
		   Node<Integer> temp = head;
		   int currPos = 0;
		   while(temp != null && currPos < pos-1) {
			   temp = temp.next;
			   currPos++;
		   }
		   if(temp != null) {
			   currNode.next = temp.next;
			   temp.next = currNode;
		   }
		   return head;
		}
	}
	
	//@@(12)@@ move last node at first of LinkedList
	public static Node<Integer> moveLastEleAtFirst(Node<Integer> head){
		Node<Integer> secondLast = null;
		Node<Integer> last = head;
		while(last.next != null) {
			secondLast = last;
			last = last.next;
		}
		last.next = head;
		secondLast.next = null;
		return last;
	}
	
	//@@(13)@@ AppendLastNnodeAtFirst
	    //Write a function to append the last 'N' nodes towards the front
       //of the singly linked list and returns the new head to the list.
	public static Node<Integer> AppendLastNnodeAtFirst(Node<Integer> head , int N){
		if(N == 0 && head == null) {
			return head;
		}
		Node<Integer> slow = head;
		Node<Integer> fast = head; 
		for(int i= 0; i<N; i++) {
			fast = fast.next;
		}
		while(fast.next != null) {
			slow = slow.next;
			fast = fast.next;
		}
		
		Node<Integer> temp = slow.next;
		fast.next = head;
		slow.next = null;
		return temp;
	}
	
	//@@(14)@@ reverse the node of LinkedList by reference
	    // not using recursion
	public static Node<Integer> reverseLLIteratively(Node<Integer> head){
		if(head == null || head.next == null) {
			return head;
		}
		Node<Integer> curr = head;
		Node<Integer> prev = null;
		Node<Integer> forw = null;
		while(curr != null) {
			forw = curr.next;
			curr.next = prev;
			prev = curr;
			curr = forw;
		}
		return prev;
		
	}
	
	//@@(15)@@ reverse the node of LinkedList recursively
	public static Node<Integer> reverseLLRecursively(Node<Integer> head){
		if(head == null || head.next == null) {
			return head;
		}
		Node<Integer> smallAns = reverseLLRecursively(head.next);
		Node<Integer> tail = smallAns;
		while(tail.next != null) {
		   tail = tail.next;
		}
		tail.next = head;
		head.next = null;
		return smallAns;
		
	}
	
	public static void main(String[] args) {
//		Node<Integer> head = takeInputLL();
		Node<Integer> head = takeInputLLBetter();
		head = reverseLLRecursively(head);
		printLL(head);
		
		
//		head = insertNodeInLL(head, 13, 99);
//		head = deleteNodeInLL(head, 3);
//		printLL(head);
		
		
		
		
//		int kthLast = kthFromLast(head, 3);
//		System.out.println(kthLast);
		
		
//		head = uniqueElemLL(head);
//		printLL(head);
		
//		int pos = nodePosition(head, 4);
//		System.out.println(pos);
//		incrementData(head);
//		printLL(head);
		
//		int count = LinkedListLength(head);
//		System.out.println(count);
//		printLL(head);

	}

}